<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.42">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="dcterms.date" content="2025-07-18">

<title>Bypassing Atmospheric Correction with BART – Erdem Karaköylü</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-dark-b53751a350365c71b6c909e95f209ed1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-22381ab97ffb8a420d3841344730e94d.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="quarto:status" content="draft">


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top"><div id="quarto-draft-alert" class="alert alert-warning"><i class="bi bi-pencil-square"></i>Draft</div>
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">Erdem Karaköylü</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../portfolio.html"> 
<span class="menu-text">Portfolio</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../resume.html"> 
<span class="menu-text">Resume</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../../blog.html"> 
<span class="menu-text">Blog</span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#summary" id="toc-summary" class="nav-link active" data-scroll-target="#summary">Summary</a></li>
  <li><a href="#why-this-matters" id="toc-why-this-matters" class="nav-link" data-scroll-target="#why-this-matters">Why This Matters</a></li>
  <li><a href="#data-overview" id="toc-data-overview" class="nav-link" data-scroll-target="#data-overview">Data Overview</a></li>
  <li><a href="#model-development" id="toc-model-development" class="nav-link" data-scroll-target="#model-development">Model Development</a>
  <ul class="collapse">
  <li><a href="#model-1-homoskedastic-noise-independent-across-wavelengths" id="toc-model-1-homoskedastic-noise-independent-across-wavelengths" class="nav-link" data-scroll-target="#model-1-homoskedastic-noise-independent-across-wavelengths">Model 1: Homoskedastic Noise, Independent Across Wavelengths</a></li>
  <li><a href="#model-2-hierarchical-noise-prior-across-wavelengths" id="toc-model-2-hierarchical-noise-prior-across-wavelengths" class="nav-link" data-scroll-target="#model-2-hierarchical-noise-prior-across-wavelengths">Model 2: Hierarchical Noise Prior Across Wavelengths</a></li>
  <li><a href="#model-3-input-dependent-heteroscedastic-noise" id="toc-model-3-input-dependent-heteroscedastic-noise" class="nav-link" data-scroll-target="#model-3-input-dependent-heteroscedastic-noise">Model 3: Input-Dependent (Heteroscedastic) Noise</a></li>
  </ul></li>
  <li><a href="#model-results" id="toc-model-results" class="nav-link" data-scroll-target="#model-results">Model Results</a></li>
  <li><a href="#calibration-leave-one-out-pit" id="toc-calibration-leave-one-out-pit" class="nav-link" data-scroll-target="#calibration-leave-one-out-pit">Calibration: Leave-One-Out PIT</a></li>
  <li><a href="#key-takeaways" id="toc-key-takeaways" class="nav-link" data-scroll-target="#key-takeaways">Key Takeaways</a></li>
  <li><a href="#whats-next" id="toc-whats-next" class="nav-link" data-scroll-target="#whats-next">What’s Next?</a></li>
  <li><a href="#links" id="toc-links" class="nav-link" data-scroll-target="#links">Links</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Bypassing Atmospheric Correction with BART</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Bayesian Additive Regression Trees</div>
    <div class="quarto-category">Remote Sensing</div>
    <div class="quarto-category">Oceanography</div>
    <div class="quarto-category">Plankton</div>
    <div class="quarto-category">Atmospheric Correction</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
    <div>
    <div class="quarto-title-meta-heading">Published</div>
    <div class="quarto-title-meta-contents">
      <p class="date">July 18, 2025</p>
    </div>
  </div>
  
    
  </div>
  


</header>


<blockquote class="blockquote">
<p>Predicting phytoplankton absorption directly from satellite top-of-atmosphere radiance using Bayesian Additive Regression Trees (BART).</p>
</blockquote>
<section id="summary" class="level2">
<h2 class="anchored" data-anchor-id="summary">Summary</h2>
<p>This study explores an alternative path in satellite ocean color retrieval: <strong>predicting phytoplankton absorption directly from top-of-atmosphere (TOA) radiance</strong> — without applying full atmospheric correction. Instead of correcting the signal, I <strong>model the relationship between radiance and in-water optical properties</strong> using <strong>Bayesian Additive Regression Trees (BART)</strong>.</p>
<p>The approach is fully probabilistic, requires minimal preprocessing, and sidesteps one of the most error-prone steps in the ocean color pipeline.</p>
<blockquote class="blockquote">
<p>💡 <strong>See the full modeling notebook</strong><br>
📓 <a href="https://github.com/your-repo/path-to-notebook.ipynb">Jupyter Notebook: BART Modeling of TOA Radiance</a></p>
</blockquote>
<hr>
</section>
<section id="why-this-matters" class="level2">
<h2 class="anchored" data-anchor-id="why-this-matters">Why This Matters</h2>
<p>Most satellite algorithms for ocean color begin with full atmospheric correction, an elaborate process sensitive to sensor calibration, aerosol assumptions, and viewing geometry. That correction can introduce more noise than it removes — especially in optically complex waters.</p>
<p>This approach bypasses this step entirely. By modeling the <strong>direct statistical relationship between TOA radiance and phytoplankton absorption</strong>, I reduce complexity and open the door to real-time and near-surface-only applications.</p>
<hr>
</section>
<section id="data-overview" class="level2">
<h2 class="anchored" data-anchor-id="data-overview">Data Overview</h2>
<p>I use the synthetic hyperspectral dataset from <strong>Valente et al.&nbsp;(2022)</strong>, focusing on:</p>
<ul>
<li><strong>Inputs</strong>: log₁₀ TOA radiance at 6 bands (412, 443, 490, 510, 555, 670 nm), corrected only for Rayleigh scattering and Fresnel reflection.</li>
<li><strong>Targets</strong>: log₁₀ phytoplankton absorption (a<sub>φ</sub>) at 443, 555, and 670 nm.</li>
</ul>
<p>These bands are common to legacy and upcoming satellite sensors, making the results widely applicable.</p>
<hr>
</section>
<section id="model-development" class="level2">
<h2 class="anchored" data-anchor-id="model-development">Model Development</h2>
<p>We developed <strong>three multivariate BART models</strong>, each predicting <strong>phytoplankton absorption at 443, 555, and 670 nm simultaneously</strong>. All models share the same inputs — log₁₀-transformed Rayleigh- and Fresnel-corrected TOA radiance at six bands — but differ in how they model uncertainty and structure the noise term.</p>
<p>This modeling progression allows us to test the sensitivity of results to increasingly flexible assumptions about the residual structure. While the mean structure (captured by BART) remains the same, the treatment of uncertainty becomes more sophisticated from Model 1 to Model 3.</p>
<hr>
<section id="model-1-homoskedastic-noise-independent-across-wavelengths" class="level3">
<h3 class="anchored" data-anchor-id="model-1-homoskedastic-noise-independent-across-wavelengths">Model 1: Homoskedastic Noise, Independent Across Wavelengths</h3>
<p>The first model assumes a separate but <strong>constant noise level</strong> for each absorption wavelength. It uses a <strong>half-normal prior</strong> on the standard deviation for each band, treating the noise as homoskedastic and uncorrelated.</p>
<p>This model serves as the baseline and is the most constrained in terms of uncertainty treatment.<br>
See <strong>Figure 1</strong> for the model structure.</p>
<p><embed src="figures/model1_dag.pdf" class="img-fluid"> <strong>Figure 1.</strong> BART model with separate homoskedastic noise terms for each target absorption band.</p>
<hr>
</section>
<section id="model-2-hierarchical-noise-prior-across-wavelengths" class="level3">
<h3 class="anchored" data-anchor-id="model-2-hierarchical-noise-prior-across-wavelengths">Model 2: Hierarchical Noise Prior Across Wavelengths</h3>
<p>In the second model, we introduce a <strong>hierarchical prior</strong> on the standard deviation parameters across wavelengths. An exponential prior governs the variability between wavelength-specific σ values, allowing the model to <strong>share information across bands</strong> while still assigning each its own uncertainty scale.</p>
<p>This encourages moderate regularization of the noise structure while remaining more flexible than Model 1.<br>
See <strong>Figure 2</strong> for the model layout.</p>
<p><embed src="figures/model2_dag.pdf" class="img-fluid"> <strong>Figure 2.</strong> BART model with a hierarchical exponential prior on wavelength-specific noise terms.</p>
<hr>
</section>
<section id="model-3-input-dependent-heteroscedastic-noise" class="level3">
<h3 class="anchored" data-anchor-id="model-3-input-dependent-heteroscedastic-noise">Model 3: Input-Dependent (Heteroscedastic) Noise</h3>
<p>The third model allows the noise to <strong>vary with the input radiance values themselves</strong> — introducing a <strong>heteroscedastic noise model</strong>. The standard deviation for each wavelength is modeled as a function of TOA radiance through a linear transformation, followed by exponentiation to ensure positivity.</p>
<p>This is the most flexible formulation and accounts for the fact that predictive uncertainty may increase (or decrease) in specific regions of input space.<br>
The structure is illustrated in <strong>Figure 3</strong>.</p>
<p><embed src="./figures/model3_dag.pdf" class="img-fluid"> <strong>Figure 3.</strong> BART model with heteroscedastic noise, where the standard deviation depends on TOA radiance via learned slopes and intercepts.</p>
<hr>
<p>By holding the BART mean function constant and varying only the noise structure, we can <strong>compare calibration, sharpness, and predictive fit</strong> across models — and better understand how uncertainty behaves across wavelengths and input regimes. This structure also positions us to extend to <strong>full Bayesian multitask learning</strong> in future work.</p>
<hr>
</section>
</section>
<section id="model-results" class="level2">
<h2 class="anchored" data-anchor-id="model-results">Model Results</h2>
<p>Each target wavelength was modeled using a separate BART regression. The models effectively captured the nonlinear relationships between TOA radiance and phytoplankton absorption, yielding tight posterior predictive intervals with minimal bias across the optical range.</p>
<p>Here is the posterior predictive check for a<sub>φ</sub>(443):</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="path/to/ppc_443.png" class="img-fluid figure-img"></p>
<figcaption>Posterior predictive check for 443 nm</figcaption>
</figure>
</div>
<p>And for a<sub>φ</sub>(555):</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="path/to/ppc_555.png" class="img-fluid figure-img"></p>
<figcaption>Posterior predictive check for 555 nm</figcaption>
</figure>
</div>
<p>And for a<sub>φ</sub>(670):</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="path/to/ppc_670.png" class="img-fluid figure-img"></p>
<figcaption>Posterior predictive check for 670 nm</figcaption>
</figure>
</div>
<p>The distributions of observed and simulated values closely align across wavelengths, indicating that the model generalizes well and captures relevant variance in the data.</p>
<hr>
</section>
<section id="calibration-leave-one-out-pit" class="level2">
<h2 class="anchored" data-anchor-id="calibration-leave-one-out-pit">Calibration: Leave-One-Out PIT</h2>
<p>To assess model calibration, I used <strong>LOO-PIT</strong> (Leave-One-Out Probability Integral Transform). This diagnostic checks whether the model’s predictive distribution is well-calibrated across observations.</p>
<p>Here’s the LOO-PIT plot for the three absorption bands:</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><img src="path/to/loo_pit.png" class="img-fluid figure-img"></p>
<figcaption>LOO-PIT plots</figcaption>
</figure>
</div>
<p>A uniform distribution indicates perfect calibration. Minor deviations near the tails suggest small over- or under-dispersion at certain wavelengths, but the overall shape confirms good fit.</p>
<blockquote class="blockquote">
<p>📖 Learn more about this diagnostic in my blog post:<br>
<a href="../blog/loo-pit-diagnostics.qmd">LOO-PIT Explained: Calibrating Bayesian Predictive Models</a></p>
</blockquote>
<hr>
</section>
<section id="key-takeaways" class="level2">
<h2 class="anchored" data-anchor-id="key-takeaways">Key Takeaways</h2>
<ul>
<li><strong>No full atmospheric correction</strong> is required to predict phytoplankton absorption.</li>
<li><strong>Bayesian Additive Regression Trees</strong> offer a powerful way to capture nonlinear, multiband relationships with built-in uncertainty estimates.</li>
<li>Model predictions show excellent agreement with ground-truth absorption data, supported by tight posterior intervals and LOO-based validation.</li>
<li>This opens the door to new operational tools that are simpler, faster, and less reliant on ancillary assumptions.</li>
</ul>
<hr>
</section>
<section id="whats-next" class="level2">
<h2 class="anchored" data-anchor-id="whats-next">What’s Next?</h2>
<ul>
<li>Extend to other IOPs like <strong>chlorophyll-a</strong> and <strong>non-algal particles</strong></li>
<li>Evaluate on <strong>real sensor data</strong> (e.g., Sentinel-3 OLCI)</li>
<li>Scale to <strong>hyperspectral input</strong> from missions like PACE</li>
<li>Experiment with <strong>causal forests</strong> and <strong>heterogeneous effect estimation</strong></li>
</ul>
<hr>
</section>
<section id="links" class="level2">
<h2 class="anchored" data-anchor-id="links">Links</h2>
<ul>
<li>🛰️ <a href="https://doi.org/10.5194/essd-2022-183">Valente et al.&nbsp;Dataset</a><br>
</li>
<li>📓 <a href="https://github.com/your-repo/path-to-notebook.ipynb">Modeling Notebook</a><br>
</li>
<li>📖 <a href="../blog/loo-pit-diagnostics.qmd">Blog Post on LOO-PIT</a><br>
</li>
<li>📝 <a href="https://your-overleaf-link.com">Draft Manuscript</a></li>
</ul>
<hr>
<p><em>Part of a broader research effort to make satellite oceanography faster, more robust, and more Bayesian.</em></p>


</section>

<script async="" defer="" src="https://scripts.simpleanalyticscdn.com/latest.js"></script></main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->




</body></html>